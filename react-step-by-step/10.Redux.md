# Redux

##  Why
> 随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。

> 管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。

> 这里的复杂性很大程度上来自于：我们总是将两个难以厘清的概念混淆在一起：变化和异步。 我称它们为曼妥思和可乐。如果把二者分开，能做的很好，但混到一起，就变得一团糟。一些库如 React 试图在视图层禁止异步和直接操作 DOM 来解决这个问题。美中不足的是，React 依旧把处理 state 中数据的问题留给了你。Redux就是为了帮你解决这个问题。

通过本系列之前内容的学习，我们了解到React的原理实际上可以理解为：UI=fn(state)，UI的变化由State决定。然而，如何维护State，更新State并不属于React关心的内容。

Redux依靠单向的数据流，使得State的维护更加清晰，可预测，可维护。

##  单向数据流
什么是单向数据流？让我们先看下面这张图：

![Redux数据流](assets/Redux-Data-Flow.png)

我们在图中看到很多的新的概念，比如：ActionCreator，Action，Reducer，Store，State Tree...先对这个图有个印象，了解完本章内容，再来回来看这个图会更理解其中的原理。

下面我们就开始了解一下，Redux是如何让我们利用单向数据流管理State的。

##  三大原则
### 单一数据源
整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。

### State只读
惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。

### 通过纯函数修改State
为了描述 action 如何改变 state tree ，你需要编写 reducers。Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。

##  一个小示例
结合单向数据流图和三大原则，我们来看一个实际的示例，理解单向数据流是如何工作的：

[Example:Counter](codes/10.redux/1.counter)
``` javascript
// index.js
'use strict';

import React from 'react';
import ReactDOM from 'react-dom';
import { createStore } from 'redux';
import Counter from './components/Counter';
import counter from './reducers';
import { increment, decrement } from './actions';

// 创建全局唯一的store，插入reducers
const store = createStore(counter);

// 呈现应用的组件
function render() {
    // 呈现时输出当前的state tree
    console.log(`state tree:    ${JSON.stringify(store.getState())}`);

    // 在div中插入组件，值来自于store.getState()，点击事件触发store.dispatch()
    ReactDOM.render(
        <Counter
            value={store.getState().count}
            onIncrement={() => store.dispatch(increment())}
            onDecrement={() => store.dispatch(decrement())}
        />,
        document.getElementById('app')
    )
}

// 初始调用render函数
render();
// 监听store，如果store中的state tree发生变更，则调用render函数重新渲染
store.subscribe(render);
```

从这个示例中，我们可以窥得Redux的基本处理流程：
1.  通过`createStore`函数，插入`reducers`，创建一个对于整个应用唯一的`store`，其中维护一个`state tree`；
2.  `render`函数将`Counter`组件呈现到div中，`Counter`组件的`value`值从`store.getState()`返回的`state tree`中获取；
3.  当用户触发`onIncrement`或`onDecrement`事件时，通过`store.dispatch`分发`action`到`reducers`处理（其中，`action`是一个带有type属性的对象，由`actionCreator`产生）；
4.  `reducers`是一些纯函数，接收旧的`state tree`和`action`，返回新的`state tree`；
5.  由于`state tree`发生了变化，此时`store`会通知并调用订阅的函数：`render`（通过`store.subscribe()`订阅）

##  基本组成
### Action
首先，让我们来给 action 下个定义。

>Action 是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。

Action本质上是一个普通的javascript对象，用于描述发生的事情，其中type属性是约定的，一般使用常量标识发生的事情。

例如：
```
const INCREMENT = 'INCREMENT';

{
  type: INCREMENT,
  ... // 可以携带任何有用的参数
}
```

### Action Creator
Action Creator是生成action的方法。上节说到Action是一个纯粹的javascript对象，而Action Creator函数用于返回Action。

一般我们除了会在Action Creator中返回Action外，还会做一些其他的操作，如：服务端交互，数据持久化...我们会在异步Action中讨论这些内容。

### Reducer
好了，我们定义了Action Creator来返回Action，描述"有事情发生了"这一事实，并没有指明应用应该如何更新state。而这正是reducer要做的事情。

``` javascript
'use strict';
import {INCREMENT, DECREMENT} from '../actions';

const stateTree = {count: 0};

function counter(state = statTree, action) {
    switch (action.type) {
        case INCREMENT:
            return {count: state.count + 1};
        case DECREMENT:
            return {count: state.count - 1};
        default:
            return state;
    }
}

export default counter;
```

我们定义了一个stateTree，作为初始化的state。并且，定义了一个`counter(state, action)`函数，处理action操作。
要注意的是：
1.  不要修改传入的state和action，且总是返回新的state；
2.  不要执行有副作用的操作，如API请求和路由跳转；
3.  不要调用非纯函数，如：Date.now() 或 Math.random();
4.  在default情况下返回旧的state。

####  拆分Reducer
设想一下如果应用变得更大，在一个reducer中处理一堆不相干的action，会带来一些维护上的混乱。
比如：

我们在原来的1.counter的基础上，添加了一个输入转换组件，从redux的原则上来看，我们需要这样一个新的reducer：

``` javascript
'use strict';
import {COUNTER_INCREMENT, COUNTER_DECREMENT} from '../actions/counter';
import {WRITER_CHANGE} from '../actions/writer';

const stateTree = {count: 0, text: '输入的内容是: '};

function reducers(state = stateTree, action) {
    switch (action.type) {
        case COUNTER_INCREMENT:
            return {count: state.count + 1};
        case COUNTER_DECREMENT:
            return {count: state.count - 1};
        case WRITER_CHANGE:
            return {text: `输入的内容是:   ${action.text}`};
        default:
            return state;
    }
}

export default reducers;
```

上面代码的弊端是很明显的，随着应用变大，stateTree会不断变大，维护会变得越来越困难。因此，redux提供了一个`combineReducers`函数能让我们拆分 Reducer。

[拆分后的代码示例](codes/10.redux/2.counter&writer)

``` javascript
// reducers/counter.js
'use strict';
import {COUNTER_INCREMENT, COUNTER_DECREMENT} from '../actions/counter';

const initState = {count: 0};

function counter(state = initState, action) {
    switch (action.type) {
        case COUNTER_INCREMENT:
            return {count: state.count + 1};
        case COUNTER_DECREMENT:
            return {count: state.count - 1};
        default:
            return state;
    }
}

export default counter;
```

``` javascript
// reducers/writer.js
'use strict';
import {WRITER_CHANGE} from '../actions/writer';

const initState = {text: '输入的内容是:   '};

function counter(state = initState, action) {
    switch (action.type) {
        case WRITER_CHANGE:
            return {text: `输入的内容是:   ${action.text}`};
        default:
            return state;
    }
}

export default counter;
```

``` javascript
// reducers/index.js
'use strict';
import {combineReducers} from 'redux';

import counter from './counter';
import writer from './writer';

export default combineReducers({counter, writer});
```

每个`reducer`只负责管理全局state tree中它负责的一部分。每个`reducer`的state参数都不同，分别对应它管理的那部分state数据。

试一下:
```
npm install
npm start
访问: http://localhost:5000
```

观察console的输出，我们会注意到虽然我们拆分了reducers和state tree，但是这并不代表我们拥有多个store或多个state tree。应用依然只存在一个唯一的state tree，只不过根据reducer的名称进行了组合。
比如：点击两下+,再输入111，我们会在console中看到这样的输出

```
state tree:    {"counter":{"count":1},"writer":{"text":"输入的内容是:   "}}
state tree:    {"counter":{"count":2},"writer":{"text":"输入的内容是:   "}}
state tree:    {"counter":{"count":2},"writer":{"text":"输入的内容是:   1"}}
state tree:    {"counter":{"count":2},"writer":{"text":"输入的内容是:   11"}}
state tree:    {"counter":{"count":2},"writer":{"text":"输入的内容是:   111"}}
```

### Store
好了，我们学会了使用 action 来描述“发生了什么”，和使用 reducers 来根据 action 更新 state 的用法。

Store 就是把它们联系到一起的对象。Store 有以下职责：

1.  维持应用的 state；
2.  提供 getState() 方法获取 state；
3.  提供 dispatch(action) 方法更新 state；
4.  通过 subscribe(listener) 注册监听器。

##  结合React

##  异步Action

##  样板示例

##  结合React-Router

##  更多资料
[Redux中文文档](http://cn.redux.js.org/docs/introduction/Ecosystem.html)
